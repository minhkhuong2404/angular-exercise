{"ast":null,"code":"import _createClass from \"/Users/minhkhuonglu/Downloads/deployment/deployment/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/minhkhuonglu/Downloads/deployment/deployment/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _slicedToArray from \"/Users/minhkhuonglu/Downloads/deployment/deployment/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/minhkhuonglu/Downloads/deployment/deployment/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport { Subject, of, Observable, from, merge } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first, switchMapTo, subscribeOn, filter } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport { ɵcacheInstance, ɵfirebaseAppFactory, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins } from '@angular/fire/compat';\nimport { isPlatformServer } from '@angular/common';\nimport * as i2 from '@angular/fire/app-check';\nimport firebase from 'firebase/compat/app'; // DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/auth, so Proxy can work with proxy-polyfill in Internet Explorer\n\nvar proxyPolyfillCompat = {\n  name: null,\n  config: null,\n  emulatorConfig: null,\n  app: null,\n  applyActionCode: null,\n  checkActionCode: null,\n  confirmPasswordReset: null,\n  createUserWithEmailAndPassword: null,\n  currentUser: null,\n  fetchSignInMethodsForEmail: null,\n  isSignInWithEmailLink: null,\n  getRedirectResult: null,\n  languageCode: null,\n  settings: null,\n  onAuthStateChanged: null,\n  onIdTokenChanged: null,\n  sendSignInLinkToEmail: null,\n  sendPasswordResetEmail: null,\n  setPersistence: null,\n  signInAndRetrieveDataWithCredential: null,\n  signInAnonymously: null,\n  signInWithCredential: null,\n  signInWithCustomToken: null,\n  signInWithEmailAndPassword: null,\n  signInWithPhoneNumber: null,\n  signInWithEmailLink: null,\n  signInWithPopup: null,\n  signInWithRedirect: null,\n  signOut: null,\n  tenantId: null,\n  updateCurrentUser: null,\n  useDeviceLanguage: null,\n  useEmulator: null,\n  verifyPasswordResetCode: null\n};\nvar USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-emulator');\nvar SETTINGS = /*#__PURE__*/new InjectionToken('angularfire2.auth.settings');\nvar TENANT_ID = /*#__PURE__*/new InjectionToken('angularfire2.auth.tenant-id');\nvar LANGUAGE_CODE = /*#__PURE__*/new InjectionToken('angularfire2.auth.langugage-code');\nvar USE_DEVICE_LANGUAGE = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-device-language');\nvar PERSISTENCE = /*#__PURE__*/new InjectionToken('angularfire.auth.persistence');\n\nvar ɵauthFactory = function ɵauthFactory(app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence) {\n  return ɵcacheInstance(\"\".concat(app.name, \".auth\"), 'AngularFireAuth', app.name, function () {\n    var auth = zone.runOutsideAngular(function () {\n      return app.auth();\n    });\n\n    if (useEmulator) {\n      auth.useEmulator.apply(auth, _toConsumableArray(useEmulator));\n    }\n\n    if (tenantId) {\n      auth.tenantId = tenantId;\n    }\n\n    auth.languageCode = languageCode;\n\n    if (useDeviceLanguage) {\n      auth.useDeviceLanguage();\n    }\n\n    if (settings) {\n      for (var _i = 0, _Object$entries = Object.entries(settings); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            k = _Object$entries$_i[0],\n            v = _Object$entries$_i[1];\n\n        auth.settings[k] = v;\n      }\n    }\n\n    if (persistence) {\n      auth.setPersistence(persistence);\n    }\n\n    return auth;\n  }, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);\n};\n\nvar AngularFireAuth = /*#__PURE__*/(function () {\n  var AngularFireAuth = /*#__PURE__*/_createClass(function AngularFireAuth(options, name, // tslint:disable-next-line:ban-types\n  platformId, zone, schedulers, useEmulator, // can't use the tuple here\n  settings, // can't use firebase.auth.AuthSettings here\n  tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n    _classCallCheck(this, AngularFireAuth);\n\n    var logins = new Subject();\n    var auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(function () {\n      return zone.runOutsideAngular(function () {\n        return import('firebase/compat/auth');\n      });\n    }), map(function () {\n      return ɵfirebaseAppFactory(options, zone, name);\n    }), map(function (app) {\n      return ɵauthFactory(app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence);\n    }), shareReplay({\n      bufferSize: 1,\n      refCount: false\n    }));\n\n    if (isPlatformServer(platformId)) {\n      this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);\n    } else {\n      // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n      //       (e.g, `import { auth } from 'firebase/compat/app'`) are getting an undefined auth object unexpectedly\n      //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n      //       There could potentially be race conditions still... but this greatly decreases the odds while\n      //       we reevaluate the API.\n      var _ = auth.pipe(first()).subscribe();\n\n      var redirectResult = auth.pipe(switchMap(function (auth) {\n        return auth.getRedirectResult().then(function (it) {\n          return it;\n        }, function () {\n          return null;\n        });\n      }), keepUnstableUntilFirst, shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      var authStateChanged = auth.pipe(switchMap(function (auth) {\n        return new Observable(function (sub) {\n          return {\n            unsubscribe: zone.runOutsideAngular(function () {\n              return auth.onAuthStateChanged(function (next) {\n                return sub.next(next);\n              }, function (err) {\n                return sub.error(err);\n              }, function () {\n                return sub.complete();\n              });\n            })\n          };\n        });\n      }));\n      var idTokenChanged = auth.pipe(switchMap(function (auth) {\n        return new Observable(function (sub) {\n          return {\n            unsubscribe: zone.runOutsideAngular(function () {\n              return auth.onIdTokenChanged(function (next) {\n                return sub.next(next);\n              }, function (err) {\n                return sub.error(err);\n              }, function () {\n                return sub.complete();\n              });\n            })\n          };\n        });\n      }));\n      this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      this.idToken = this.user.pipe(switchMap(function (user) {\n        return user ? from(user.getIdToken()) : of(null);\n      }));\n      this.idTokenResult = this.user.pipe(switchMap(function (user) {\n        return user ? from(user.getIdTokenResult()) : of(null);\n      }));\n      this.credential = merge(redirectResult, logins, // pipe in null authState to make credential zipable, just a weird devexp if\n      // authState and user go null to still have a credential\n      this.authState.pipe(filter(function (it) {\n        return !it;\n      }))).pipe( // handle the { user: { } } when a user is already logged in, rather have null\n      // TODO handle the type corcersion better\n      map(function (credential) {\n        return (credential === null || credential === void 0 ? void 0 : credential.user) ? credential : null;\n      }), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n    }\n\n    return ɵlazySDKProxy(this, auth, zone, {\n      spy: {\n        apply: function apply(name, _, val) {\n          // If they call a signIn or createUser function listen into the promise\n          // this will give us the user credential, push onto the logins Subject\n          // to be consumed in .credential\n          if (name.startsWith('signIn') || name.startsWith('createUser')) {\n            // TODO fix the types, the trouble is UserCredential has everything optional\n            val.then(function (user) {\n              return logins.next(user);\n            });\n          }\n        }\n      }\n    });\n  });\n\n  AngularFireAuth.ɵfac = function AngularFireAuth_Factory(t) {\n    return new (t || AngularFireAuth)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8), i0.ɵɵinject(i2.AppCheckInstances, 8));\n  };\n\n  AngularFireAuth.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFireAuth,\n    factory: AngularFireAuth.ɵfac,\n    providedIn: 'any'\n  });\n  return AngularFireAuth;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\nɵapplyMixins(AngularFireAuth, [proxyPolyfillCompat]);\nvar AngularFireAuthModule = /*#__PURE__*/(function () {\n  var AngularFireAuthModule = /*#__PURE__*/_createClass(function AngularFireAuthModule() {\n    _classCallCheck(this, AngularFireAuthModule);\n\n    firebase.registerVersion('angularfire', VERSION.full, 'auth-compat');\n  });\n\n  AngularFireAuthModule.ɵfac = function AngularFireAuthModule_Factory(t) {\n    return new (t || AngularFireAuthModule)();\n  };\n\n  AngularFireAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFireAuthModule\n  });\n  AngularFireAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFireAuth]\n  });\n  return AngularFireAuthModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireAuth, AngularFireAuthModule, LANGUAGE_CODE, PERSISTENCE, SETTINGS, TENANT_ID, USE_DEVICE_LANGUAGE, USE_EMULATOR, ɵauthFactory }; //# sourceMappingURL=angular-fire-compat-auth.js.map","map":null,"metadata":{},"sourceType":"module"}